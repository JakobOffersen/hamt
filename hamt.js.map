{"version":3,"sources":["hamt.js"],"names":["hamt","SIZE","BUCKET_SIZE","Math","pow","MASK","MAX_INDEX_NODE","MIN_ARRAY_NODE","defaultValBind","f","defaultValue","x","arguments","length","hash","type","str","i","len","c","charCodeAt","popcount","hashFragment","shift","h","toBitmap","fromBitmap","bitmap","bit","arrayUpdate","at","v","arr","out","Array","arraySpliceOut","g","arraySpliceIn","LEAF","COLLISION","INDEX","ARRAY","Leaf","key","value","_modify","Leaf__modify","Collision","children","Collision__modify","IndexedNode","mask","IndexedNode__modify","ArrayNode","size","ArrayNode__modify","isLeaf","node","expand","frag","child","subNodes","count","pack","removed","elements","elem","mergeLeaves","h1","n1","h2","n2","subH1","subH2","updateCollisionList","list","k","__hamt_delete_op","newValue","__hamt_set_op","op","undefined","currentValue","indx","exists","newChild","empty__modify","current","_","Map","root","_root","_size","prototype","__hamt_isMap","setTree","tryGetHash","alt","map","tryGet","getHash","get","nothing","hasHash","has","empty","isMap","isEmpty","modifyHash","newRoot","modify","modifyValueHash","modifyValue","setHash","set","del","removeHash","deleteHash","remove","delete","appk","lazyVisitChildren","lazyVisit","rest","DONE","done","MapIterator","next","v0","Symbol","iterator","visit","buildPairs","entries","buildKeys","keys","buildValues","values","fold","z","m","toVisit","pop","push","forEach","Object","defineProperty","module","exports","define","amd"],"mappings":"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","file":"hamt.js","sourcesContent":["/**\n    @fileOverview Hash Array Mapped Trie.\n\n    Code based on: https://github.com/exclipy/pdata\n*/\nconst hamt = {}; // export\n\n/* Configuration\n ******************************************************************************/\nconst SIZE = 5;\n\nconst BUCKET_SIZE = Math.pow(2, SIZE);\n\nconst MASK = BUCKET_SIZE - 1;\n\nconst MAX_INDEX_NODE = BUCKET_SIZE / 2;\n\nconst MIN_ARRAY_NODE = BUCKET_SIZE / 4;\n\n/*\n ******************************************************************************/\nconst defaultValBind = (f, defaultValue) =>\n    function(x) {\n        return f(arguments.length === 0 ? defaultValue : x);\n    };\n\n/**\n    Get 32 bit hash of string.\n\n    Based on:\n    http://stackoverflow.com/questions/7616461/generate-a-hash-from-string-in-javascript-jquery\n*/\nconst hash = hamt.hash = str => {\n    const type = typeof str;\n    if (type === 'number')\n        return str;\n    if (type !== 'string')\n        str += '';\n\n    let hash = 0;\n    for (let i = 0, len = str.length; i < len; ++i) {\n        const c = str.charCodeAt(i);\n        hash = (((hash << 5) - hash) + c) | 0;\n    }\n    return hash;\n};\n\n/* Bit Ops\n ******************************************************************************/\n/**\n    Hamming weight.\n\n    Taken from: http://jsperf.com/hamming-weight\n*/\nconst popcount = (x) => {\n    x -= ((x >> 1) & 0x55555555);\n    x = (x & 0x33333333) + ((x >> 2) & 0x33333333);\n    x = (x + (x >> 4)) & 0x0f0f0f0f;\n    x += (x >> 8);\n    x += (x >> 16);\n    return (x & 0x7f);\n};\n\nconst hashFragment = (shift, h) =>\n    (h >>> shift) & MASK;\n\nconst toBitmap = x =>\n    1 << x;\n\nconst fromBitmap = (bitmap, bit) =>\n    popcount(bitmap & (bit - 1));\n\n/* Array Ops\n ******************************************************************************/\n/**\n    Set a value in an array.\n\n    @param at Index to change.\n    @param v New value\n    @param arr Array.\n*/\nconst arrayUpdate = (at, v, arr) => {\n    const len = arr.length;\n    const out = new Array(len);\n    for (let i = 0; i < len; ++i)\n        out[i] = arr[i];\n    out[at] = v;\n    return out;\n};\n\n/**\n    Remove a value from an array.\n\n    @param at Index to remove.\n    @param arr Array.\n*/\nconst arraySpliceOut = (at, arr) => {\n    const len = arr.length;\n    const out = new Array(len - 1);\n    let i = 0, g = 0;\n    while (i < at)\n        out[g++] = arr[i++];\n    ++i;\n    while (i < len)\n        out[g++] = arr[i++];\n    return out;\n};\n\n/**\n    Insert a value into an array.\n\n    @param at Index to insert at.\n    @param v Value to insert,\n    @param arr Array.\n*/\nconst arraySpliceIn = (at, v, arr) => {\n    const len = arr.length;\n    const out = new Array(len + 1);\n    let i = 0, g = 0;\n    while (i < at)\n        out[g++] = arr[i++];\n    out[g++] = v;\n    while (i < len)\n        out[g++] = arr[i++];\n    return out;\n};\n\n/* Node Structures\n ******************************************************************************/\nconst LEAF = 1;\nconst COLLISION = 2;\nconst INDEX = 3;\nconst ARRAY = 4;\n\n/**\n    Leaf holding a value.\n\n    @member hash Hash of key.\n    @member key Key.\n    @member value Value stored.\n*/\nconst Leaf = (hash, key, value) => ({\n    type: LEAF,\n    hash: hash,\n    key: key,\n    value: value,\n    _modify: Leaf__modify\n});\n\n/**\n    Leaf holding multiple values with the same hash but different keys.\n\n    @member hash Hash of key.\n    @member children Array of collision children node.\n*/\nconst Collision = (hash, children) => ({\n    type: COLLISION,\n    hash: hash,\n    children: children,\n    _modify: Collision__modify\n});\n\n/**\n    Internal node with a sparse set of children.\n\n    Uses a bitmap and array to pack children.\n\n    @member mask Bitmap that encode the positions of children in the array.\n    @member children Array of child nodes.\n*/\nconst IndexedNode = (mask, children) => ({\n    type: INDEX,\n    mask: mask,\n    children: children,\n    _modify: IndexedNode__modify\n});\n\n/**\n    Internal node with many children.\n\n    @member size Number of children.\n    @member children Array of child nodes.\n*/\nconst ArrayNode = (size, children) => ({\n    type: ARRAY,\n    size: size,\n    children: children,\n    _modify: ArrayNode__modify\n});\n\n/**\n    Is `node` a leaf node?\n*/\nconst isLeaf = node =>\n    (node.type === LEAF || node.type === COLLISION);\n\n/* Internal node operations.\n ******************************************************************************/\n/**\n    Expand an indexed node into an array node.\n\n    @param frag Index of added child.\n    @param child Added child.\n    @param mask Index node mask before child added.\n    @param subNodes Index node children before child added.\n*/\nconst expand = (frag, child, bitmap, subNodes) => {\n    const arr = [];\n    let bit = bitmap;\n    let count = 0;\n    for (let i = 0; bit; ++i) {\n        if (bit & 1)\n            arr[i] = subNodes[count++];\n        bit >>>= 1;\n    }\n    arr[frag] = child;\n    return ArrayNode(count + 1, arr);\n};\n\n/**\n    Collapse an array node into a indexed node.\n\n    @param count Number of elements in new array.\n    @param removed Index of removed element.\n    @param elements Array node children before remove.\n*/\nconst pack = (count, removed, elements) => {\n    const children = new Array(count - 1);\n    let g = 0;\n    let bitmap = 0;\n    for (let i = 0, len = elements.length; i < len; ++i) {\n        if (i !== removed) {\n            const elem = elements[i];\n            if (elem) {\n                children[g++] = elem;\n                bitmap |= 1 << i;\n            }\n        }\n    }\n    return IndexedNode(bitmap, children);\n};\n\n/**\n    Merge two leaf nodes.\n\n    @param shift Current shift.\n    @param h1 Node 1 hash.\n    @param n1 Node 1.\n    @param h2 Node 2 hash.\n    @param n2 Node 2.\n*/\nconst mergeLeaves = (shift, h1, n1, h2, n2) => {\n    if (h1 === h2)\n        return Collision(h1, [n2, n1]);\n\n    const subH1 = hashFragment(shift, h1);\n    const subH2 = hashFragment(shift, h2);\n    return IndexedNode(toBitmap(subH1) | toBitmap(subH2),\n        subH1 === subH2\n            ? [mergeLeaves(shift + SIZE, h1, n1, h2, n2)]\n            : subH1 < subH2 ? [n1, n2] : [n2, n1]);\n};\n\n/**\n    Update an entry in a collision list.\n\n    @param hash Hash of collision.\n    @param list Collision list.\n    @param f Update function.\n    @param k Key to update.\n    @param size Size reference\n*/\nconst updateCollisionList = (h, list, f, k, size) => {\n    const len = list.length;\n    for (let i = 0; i < len; ++i) {\n        const child = list[i];\n        if (child.key === k) {\n            const value = child.value;\n            if (f.__hamt_delete_op) {\n                --size.value\n                return arraySpliceOut(i, list);\n            }\n            const newValue = f.__hamt_set_op ? f.value : f(value);\n            if (newValue === value)\n                return list;\n            return arrayUpdate(i, Leaf(h, k, newValue), list);\n        }\n    }\n\n    if (f.__hamt_delete_op)\n        return list;\n    const newValue = f.__hamt_set_op ? f.value : f();\n    ++size.value;\n    return arrayUpdate(len, Leaf(h, k, newValue), list);\n};\n\n/* Editing\n ******************************************************************************/\nconst Leaf__modify = function(shift, op, h, k, size) {\n    if (k === this.key) {\n        if (op.__hamt_delete_op) {\n            --size.value;\n            return undefined;\n        }\n        const currentValue = this.value;\n        const newValue = op.__hamt_set_op ? op.value : op(currentValue);\n        return newValue === currentValue ? this : Leaf(h, k, newValue);\n    }\n    if (op.__hamt_delete_op)\n        return this;\n    const newValue = op.__hamt_set_op ? op.value : op();\n    ++size.value;\n    return mergeLeaves(shift, this.hash, this, h, Leaf(h, k, newValue));\n};\n\nconst Collision__modify = function(shift, op, h, k, size) {\n    if (h === this.hash) {\n        const list = updateCollisionList(this.hash, this.children, op, k, size);\n        if (list === this.children)\n            return this;\n\n        return list.length > 1\n            ? Collision(this.hash, list)\n            : list[0]; // collapse single element collision list\n    }\n    if (op.__hamt_delete_op)\n        return this;\n    const newValue = op.__hamt_set_op ? op.value : op();\n    ++size.value;\n    return mergeLeaves(shift, this.hash, this, h, Leaf(h, k, newValue));\n};\n\nconst IndexedNode__modify = function(shift, op, h, k, size) {\n    const mask = this.mask;\n    const children = this.children;\n    const frag = hashFragment(shift, h);\n    const bit = toBitmap(frag);\n    const indx = fromBitmap(mask, bit);\n    const exists = mask & bit;\n    if (!exists) { // add\n        const newChild = empty__modify(shift + SIZE, op, h, k, size);\n        if (!newChild)\n            return this;\n        \n        return children.length >= MAX_INDEX_NODE\n            ? expand(frag, newChild, mask, children)\n            : IndexedNode(\n                mask | bit,\n                arraySpliceIn(indx, newChild, children));\n    }\n\n    const current = children[indx];\n    const newChild = current._modify(shift + SIZE, op, h, k, size);\n    if (current === newChild)\n        return this;\n\n    if (!newChild) { // remove\n        const bitmap = mask & ~bit;\n        if (!bitmap) \n            return undefined;\n        \n        return children.length === 2 && isLeaf(children[indx ^ 1])\n            ? children[indx ^ 1] // collapse\n            : IndexedNode(\n                bitmap,\n                arraySpliceOut(indx, children));\n    }\n\n    // modify\n    return children.length === 1 && isLeaf(newChild)\n        ? newChild // propagate collapse\n        : IndexedNode(\n            mask,\n            arrayUpdate(indx, newChild, children));\n};\n\nconst ArrayNode__modify = function(shift, op, h, k, size) {\n    const count = this.size;\n    const children = this.children;\n    const frag = hashFragment(shift, h);\n    const child = children[frag];\n    const newChild = child ? child._modify(shift + SIZE, op, h, k, size) : empty__modify(shift + SIZE, op, h, k, size);\n\n    if (child === newChild)\n        return this;\n\n    if (!child && newChild) { // add\n        return ArrayNode(\n            count + 1,\n            arrayUpdate(frag, newChild, children))\n    }\n    if (child && !newChild) { // remove\n        return count - 1 <= MIN_ARRAY_NODE\n            ? pack(count, frag, children)\n            : ArrayNode(\n                count - 1,\n                arrayUpdate(frag, undefined, children))\n    }\n\n    // modify\n    return ArrayNode(\n        count,\n        arrayUpdate(frag, newChild, children));\n};\n\nconst empty__modify = (_, op, h, k, size) => {\n    if (op.__hamt_delete_op)\n        return undefined;\n    const newValue = op.__hamt_set_op ? op.value : op();\n    ++size.value;\n    return Leaf(h, k, newValue);\n};\n\n/*\n ******************************************************************************/\nfunction Map(root, size) {\n    this._root = root;\n    this._size = size;\n};\n\nMap.prototype.__hamt_isMap = true;\n\nMap.prototype.setTree = function(root, size) {\n    return root === this._root ? this : new Map(root, size);\n};\n\n/* Queries\n ******************************************************************************/\n/**\n    Lookup the value for `key` in `map` using a custom `hash`.\n\n    Returns the value or `alt` if none.\n*/\nconst tryGetHash = hamt.tryGetHash = (alt, hash, key, map) => {\n    if (!map._root)\n        return alt;\n\n    let node = map._root;\n    let shift = 0;\n    while (true) switch (node.type) {\n        case LEAF:\n            {\n                return key === node.key ? node.value : alt;\n            }\n        case COLLISION:\n            {\n                if (hash === node.hash) {\n                    const children = node.children;\n                    for (let i = 0, len = children.length; i < len; ++i) {\n                        const child = children[i];\n                        if (key === child.key)\n                            return child.value;\n                    }\n                }\n                return alt;\n            }\n        case INDEX:\n            {\n                const frag = hashFragment(shift, hash);\n                const bit = toBitmap(frag);\n                if (node.mask & bit) {\n                    node = node.children[fromBitmap(node.mask, bit)];\n                    shift += SIZE;\n                    break;\n                }\n                return alt;\n            }\n        case ARRAY:\n            {\n                node = node.children[hashFragment(shift, hash)];\n                if (node) {\n                    shift += SIZE;\n                    break;\n                }\n                return alt;\n            }\n        default:\n            return alt;\n    }\n};\n\nMap.prototype.tryGetHash = function(alt, hash, key) {\n    return tryGetHash(alt, hash, key, this);\n};\n\n/**\n    Lookup the value for `key` in `map` using internal hash function.\n\n    @see `tryGetHash`\n*/\nconst tryGet = hamt.tryGet = (alt, key, map) =>\n    tryGetHash(alt, hash(key), key, map);\n\nMap.prototype.tryGet = function(alt, key) {\n    return tryGet(alt, key, this);\n};\n\n/**\n    Lookup the value for `key` in `map` using a custom `hash`.\n\n    Returns the value or `undefined` if none.\n*/\nconst getHash = hamt.getHash = (hash, key, map) =>\n    tryGetHash(undefined, hash, key, map);\n\nMap.prototype.getHash = function(hash, key) {\n    return getHash(hash, key, this);\n};\n\n/**\n    Lookup the value for `key` in `map` using internal hash function.\n\n    @see `get`\n*/\nconst get = hamt.get = (key, map) =>\n    tryGetHash(undefined, hash(key), key, map);\n\nMap.prototype.get = function(key, alt) {\n    return tryGet(alt, key, this);\n};\n\nconst nothing = ({});\n/**\n    Does an entry exist for `key` in `map`? Uses custom `hash`.\n*/\nconst hasHash = hamt.has = (hash, key, map) =>\n    tryGetHash(nothing, hash, key, map) !== nothing;\n\nMap.prototype.hasHash = function(hash, key) {\n    return hasHash(hash, key, this);\n};\n\n/**\n    Does an entry exist for `key` in `map`? Uses internal hash function.\n*/\nconst has = hamt.has = (key, map) =>\n    hasHash(hash(key), key, map);\n\nMap.prototype.has = function(key) {\n    return has(key, this);\n};\n\n/**\n    Empty node.\n*/\nhamt.empty = new Map(undefined, 0);\n\n/**\n    Is `value` a map?\n*/\nhamt.isMap = (value) =>\n    !!(value && value.__hamt_isMap);\n\n/**\n    Does `map` contain any elements?\n*/\nhamt.isEmpty = (map) =>\n    hamt.isMap(map) && !map._root;\n\nMap.prototype.isEmpty = function() {\n    return hamt.isEmpty(this);\n};\n\n\n/* Updates\n ******************************************************************************/\n/**\n    Alter the value stored for `key` in `map` using function `f` using\n    custom hash.\n\n    `f` is invoked with the current value for `k` if it exists,\n    or `defaultValue` if it is specified. Otherwise, `f` is invoked with no arguments\n    if no such value exists.\n\n    `modify` will always either update or insert a value into the map.\n\n    Returns a map with the modified value. Does not alter `map`.\n*/\nconst modifyHash = hamt.modifyHash = (f, hash, key, map) => {\n    const size = { value: map._size };\n    const newRoot = map._root ? map._root._modify(0, f, hash, key, size) : empty__modify(0, f, hash, key, size);\n    return map.setTree(newRoot, size.value);\n};\n\nMap.prototype.modifyHash = function(hash, key, f) {\n    return modifyHash(f, hash, key, this);\n};\n\n/**\n    Alter the value stored for `key` in `map` using function `f` using\n    internal hash function.\n\n    @see `modifyHash`\n*/\nconst modify = hamt.modify = (f, key, map) =>\n    modifyHash(f, hash(key), key, map);\n\nMap.prototype.modify = function(key, f) {\n    return modify(f, key, this);\n};\n\n/**\n    Same as `modifyHash`, but invokes `f` with `defaultValue` if no entry exists.\n\n    @see `modifyHash`\n*/\nconst modifyValueHash = hamt.modifyValueHash = (f, defaultValue, hash, key, map) =>\n    modifyHash(defaultValBind(f, defaultValue), hash, key, map);\n\nMap.prototype.modifyValueHash = function(hash, key, f, defaultValue) {\n    return modifyValueHash(f, defaultValue, hash, key, this);\n};\n\n/**\n    @see `modifyValueHash`\n*/\nconst modifyValue = hamt.modifyValue = (f, defaultValue, key, map) =>\n    modifyValueHash(f, defaultValue, hash(key), key, map);\n\nMap.prototype.modifyValue = function(key, f, defaultValue) {\n    return modifyValue(f, defaultValue, key, this);\n};\n\n/**\n    Store `value` for `key` in `map` using custom `hash`.\n\n    Returns a map with the modified value. Does not alter `map`.\n*/\nconst setHash = hamt.setHash = function(hash, key, value, map) {\n    return modifyHash({ __hamt_set_op: true, value: value }, hash, key, map);\n}\n\nMap.prototype.setHash = function(hash, key, value) {\n    return setHash(hash, key, value, this);\n};\n\n/**\n    Store `value` for `key` in `map` using internal hash function.\n\n    @see `setHash`\n*/\nconst set = hamt.set = (key, value, map) =>\n    setHash(hash(key), key, value, map);\n\nMap.prototype.set = function(key, value) {\n    return set(key, value, this);\n};\n\n/**\n    Remove the entry for `key` in `map`.\n\n    Returns a map with the value removed. Does not alter `map`.\n*/\nconst del = { __hamt_delete_op: true };\nconst removeHash = hamt.removeHash = (hash, key, map) =>\n    modifyHash(del, hash, key, map);\n\nMap.prototype.removeHash = Map.prototype.deleteHash = function(hash, key) {\n    return removeHash(hash, key, this);\n};\n\n/**\n    Remove the entry for `key` in `map` using internal hash function.\n\n    @see `removeHash`\n*/\nconst remove = hamt.remove = (key, map) =>\n    removeHash(hash(key), key, map);\n\nMap.prototype.remove = Map.prototype.delete = function(key) {\n    return remove(key, this);\n};\n\n/* Traversal\n ******************************************************************************/\n/**\n    Apply a continuation.\n*/\nconst appk = k =>\n    k && lazyVisitChildren(k.len, k.children, k.i, k.f, k.k);\n\n/**\n    Recursively visit all values stored in an array of nodes lazily.\n*/\nconst lazyVisitChildren = (len, children, i, f, k) => {\n    while (i < len) {\n        const child = children[i++];\n        if (child)\n            return lazyVisit(child, f, {len, children, i, f, k});\n    }\n    return appk(k);\n};\n\n/**\n    Recursively visit all values stored in `node` lazily.\n*/\nconst lazyVisit = (node, f, k) => {\n    if (node.type === LEAF) \n        return { value: f(node), rest: k };\n\n    const children = node.children;\n    return lazyVisitChildren(children.length, children, 0, f, k);\n};\n\nconst DONE = { done: true };\n\n/**\n    Javascript iterator over a map.\n*/\nfunction MapIterator(v) {\n    this.v = v;\n};\n\nMapIterator.prototype.next = function() {\n    if (!this.v)\n        return DONE;\n    const v0 = this.v;\n    this.v = appk(v0.rest);\n    return v0;\n};\n\nMapIterator.prototype[Symbol.iterator] = function() {\n    return this;\n};\n\n/**\n    Lazily visit each value in map with function `f`.\n*/\nconst visit = (map, f) =>\n    new MapIterator(map._root ? lazyVisit(map._root, f) : undefined);\n\n/**\n    Get a Javascript iterator of `map`.\n\n    Iterates over `[key, value]` arrays.\n*/\nconst buildPairs = (x) => [x.key, x.value];\nconst entries = hamt.entries = (map) =>\n    visit(map, buildPairs);\n\nMap.prototype.entries = Map.prototype[Symbol.iterator] = function() {\n    return entries(this);\n};\n\n/**\n    Get array of all keys in `map`.\n\n    Order is not guaranteed.\n*/\nconst buildKeys = (x) => x.key;\nconst keys = hamt.keys = (map) =>\n    visit(map, buildKeys);\n\nMap.prototype.keys = function() { return keys(this); }\n\n/**\n    Get array of all values in `map`.\n\n    Order is not guaranteed, duplicates are preserved.\n*/\nconst buildValues = x => x.value;\nconst values = hamt.values = Map.prototype.values = map =>\n    visit(map, buildValues);\n\nMap.prototype.values = function() {\n    return values(this);\n};\n\n/* Fold\n ******************************************************************************/\n/**\n    Visit every entry in the map, aggregating data.\n\n    Order of nodes is not guaranteed.\n\n    @param f Function mapping accumulated value, value, and key to new value.\n    @param z Starting value.\n    @param m HAMT\n*/\nconst fold = hamt.fold = (f, z, m) => {\n    const root = m._root;\n    if (!root)\n        return z;\n\n    if (root.type === LEAF)\n        return f(z, root.value, root.key);\n\n    const toVisit = [root.children];\n    let children;\n    while (children = toVisit.pop()) {\n        for (let i = 0, len = children.length; i < len;) {\n            const child = children[i++];\n            if (child) {\n                if (child.type === LEAF)\n                    z = f(z, child.value, child.key);\n                else\n                    toVisit.push(child.children);\n            }\n        }\n    }\n    return z;\n};\n\nMap.prototype.fold = function(f, z) {\n    return fold(f, z, this);\n};\n\n/**\n    Visit every entry in the map, aggregating data.\n\n    Order of nodes is not guaranteed.\n\n    @param f Function invoked with value and key\n    @param map HAMT\n*/\nconst forEach = hamt.forEach = (f, map) =>\n    fold((_, value, key) => f(value, key, map), null, map);\n\nMap.prototype.forEach = function(f) {\n    return forEach(f, this);\n};\n\n/* Aggregate\n ******************************************************************************/\n/**\n    Get the number of entries in `map`.\n*/\nconst count = hamt.count = map =>\n    map._size;\n\nMap.prototype.count = function() {\n    return count(this);\n};\n\nObject.defineProperty(Map.prototype, 'size', {\n    get: Map.prototype.count\n});\n\n/* Export\n ******************************************************************************/\nif (typeof module !== 'undefined' && module.exports) {\n    module.exports = hamt;\n} else if (typeof define === 'function' && define.amd) {\n    define('hamt', [], () => hamt);\n} else {\n    this.hamt = hamt;\n}\n"]}